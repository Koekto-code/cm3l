require <libc/stdio>

// 1. где граница между объявлениями функций
// 2. как распарсить, если точно известно, что последовательность токенов описывает одну функцию

// простейший случай
int main() {
	return 0;
}
// 1. первый токен- тип
// 2. второй токен- айди
// 3. далее сразу группа объявлений переменных
// 4. затем тело функции

ns::int ns::sub::myfunc1 (float a) {
	return a;
}
// 1. спарсить сложное имя с 1 токена
// 2. конец известен. продолжить для айди
// 3. далее сразу группа
// 4. тело

decltype (something) ns::sub::myfunc1 (float a) {
	return a;
}
// 1. определить начало тела
// если тело в фигурных скобках, найти открывающую, идя с конца
// иначе капец

// 1. определить расположение списка аргументов
// это или пустая группа, или группа, содержащая объявления переменных
// 2. спарсить тело
// 3. дописать ф-цию сложного имени для парсинга с конца
// 4. все что осталось- простое выражение =]

decltype(myvar) somefunc(float a) unsafe unsafe {
	decltype (myvar) res = *(int *)&a;
	return res;
}

getsmth (vv) [call2(6.8)] ns::fn7 ()
	st * st + st; // body

decltype (vv) fn7() {
	return st * st + st;
}

vvt fn7 ()
	st * st + st;

ns::type fn7 () {
	return st * st + st;
}

// ===================================================================
// Объявление переменной

// имеет высший приоритет, чем все бинарные операторы.
// как спарсить (условие - точно известны границы выражения)
// простейший случай
int a
//

int ns::myvar
// 1. первый токен- тип
// 2. спарсить сложное имя

space::sometype ns::fvv;
// 1. спарсить сложное имя типа
// 2. спарсить сложное имя

typename decltype(a) hbkhjbhk::somevar;
// 1. если указан typename, спарсить выражение


// переменная может быть объявлена и без типа (тогда тип будет object)
// при этом такое объявление может быть только одиночным или в связке с присваивающими бинарными операторами.
a;
ns::myvar = 78;
hbjlbhlb;

3 + int main

callsmth (yu::aabb) [2] ns::myvar = 3 + (ns::callsmth) (yu::aabb) [1] smth = y + 7 * i;
// callsmth (yu::aabb) [2] ns::myvar
// 3 + ns::callsmth (yu::aabb) [1] smth
// y + 7 * i

// callsmth (yu::aabb) [2] ns::myvar
// 3 + (ns::callsmth) (yu::aabb) [1] smth

// гипотеза: если разбивать рекурсивно части бинарных операторов,
// определенно это дойдет до литерала, обращения к переменной, группы или последовательности.
// здесь пригодится s_stParseAnything (s_stMinimalPart), парсящая минимальную целую часть выражения.
// callsmth (yu::aabb) [2] ns::myvar
// (ns::callsmth) (yu::aabb) [1] smth

// предыдущим токеном было выражение со значением, значит это вызов функции
// (yu::aabb) [2] ns::myvar
// (yu::aabb) [1] smth

// предыдущим токеном было выражение со значением, значит это индексация
// [2] ns::myvar
// [1] smth

// первый токен- VVN, пред. токеном было выражение со значением, значит это определение переменной.
// спарсить сложное имя и это конец. если не конец, значит ошибка
// ns::myvar
// smth

